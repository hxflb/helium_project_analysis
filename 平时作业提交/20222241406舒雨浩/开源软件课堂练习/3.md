A*算法是一种启发式搜索算法，用于在图中找到从起始节点到目标节点的最短路径。以下是A*算法的主要实现步骤和原理，以及代码中的详细注释说明。

### A*算法原理

A*算法的核心思想是在搜索过程中结合代价函数和启发式函数，从而实现较高效的最短路径求解。它综合了两部分信息：

1. **实际代价（g(n)）**：从起点到某个节点的实际代价，通常是路径长度或消耗的资源。
2. **启发式代价（h(n)）**：从该节点到目标节点的估计代价，用于指导算法快速收敛。常见的启发式函数有曼哈顿距离、欧几里得距离等。

A*算法的核心是通过评价函数 \(f(n) = g(n) + h(n)\) 来选择下一个扩展的节点。其中，\(g(n)\) 是当前路径的代价，\(h(n)\) 是启发式估计，\(f(n)\) 则是总估计代价。算法每次扩展当前 \(f(n)\) 最小的节点，直至找到目标节点。

### A*算法运行过程

1. **初始化**：
   - 将起点节点添加到开放列表（open list），初始时开放列表仅包含起点。
   - 将终点节点设置为目标。
   - 闭合列表（closed list）为空。

2. **循环搜索**：
   - 从开放列表中选取 \(f(n) = g(n) + h(n)\) 值最小的节点 \(n\)，即选择估计总代价最小的节点作为当前扩展节点。
   - 如果当前节点是目标节点，搜索结束，并通过回溯路径生成最终的最短路径。
   - 否则，将当前节点从开放列表中移除，加入闭合列表。

3. **扩展当前节点**：
   - 对当前节点的所有邻居节点进行如下操作：
     - 如果邻居节点在闭合列表中，则跳过。
     - 如果邻居节点不在开放列表中，计算其 \(g(n)\) 和 \(h(n)\) 值，并将其加入开放列表，设置当前节点为其父节点。
     - 如果邻居节点已经在开放列表中，检查新的路径是否更优，即检查当前路径的 \(g(n)\) 是否小于已有路径的 \(g(n)\) 值。如果更优，则更新其 \(g(n)\)、父节点，并重新计算 \(f(n)\)。

4. **重复搜索**：
   - 重复步骤 2 和步骤 3，直到找到目标节点或开放列表为空（无解）。

    
